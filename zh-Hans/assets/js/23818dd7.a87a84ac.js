"use strict";(self.webpackChunknext_id_doc=self.webpackChunknext_id_doc||[]).push([[9705],{8456:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(6600),o=(t(9496),t(9613));t(9295);const i={title:"Go"},a=void 0,s={unversionedId:"developer-guide/go",id:"developer-guide/go",title:"Go",description:"Proof Service",source:"@site/i18n/zh-Hans/docusaurus-plugin-content-docs/current/developer-guide/go.md",sourceDirName:"developer-guide",slug:"/developer-guide/go",permalink:"/zh-Hans/developer-guide/go",draft:!1,editUrl:"https://github.com/nextdotid/docs/edit/main/docs/developer-guide/go.md",tags:[],version:"current",frontMatter:{title:"Go"},sidebar:"docs",previous:{title:"Workflow",permalink:"/zh-Hans/auth-service/as-workflow"},next:{title:"Rust",permalink:"/zh-Hans/developer-guide/rust"}},d={},c=[{value:"Proof Service",id:"proof-service",level:2}],l={toc:c};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"proof-service"},"Proof Service"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You could git clone and run this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nextdotid/Signature-Generating-Sample/tree/main/go"},"Go open demo")," as a help")),(0,o.kt)("p",null,"The core example of codes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="cmd/playground.go"',title:'"cmd/playground.go"'},'package main\n\nimport (\n    "crypto/ecdsa"\n    "fmt"\n\n    "github.com/ethereum/go-ethereum/common/hexutil"\n    "github.com/ethereum/go-ethereum/crypto"\n)\n\nconst (\n    // ATTENTION! We intently replaced the last three digit of private key to be xxx.\n    // Private key is everything and NEVER expose it to others or publicly\n    SECRET_KEY   = "43c25fecc20e6b2a0d86c81a0202d125c0181deb9975d1170d80378c7e05bxxx"\n    SIGN_PAYLOAD = "Test123123!"\n)\n\nfunc main() {\n    sk, err := crypto.HexToECDSA(SECRET_KEY)\n    if err != nil {\n        panic(err)\n    }\n\n    sign, err := signPersonal([]byte(SIGN_PAYLOAD), sk)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf("Signature: %s\\n", hexutil.Encode(sign))\n    // Signature: 0x52f210dadad13c4c8d0656e7380300a367a056631cf26950baa7de4f580187795c76b5fc94de5bd0b8af4d5df432687d900402cba86a12570af56be35ba8d56401\n}\n\n// signPersonal signs a payload using given secret key.\nfunc signPersonal(payload []byte, sk *ecdsa.PrivateKey) (signature []byte, err error) {\n    digest := signPersonalDigest(payload)\n    signature, err = crypto.Sign(digest, sk)\n    if err != nil {\n        return nil, err\n    }\n\n    return signature, nil\n}\n\n// signPersonalDigest hashes the given payload with eth.personal.sign struct.\nfunc signPersonalDigest(data []byte) []byte {\n    messsage := fmt.Sprintf("\\x19Ethereum Signed Message:\\n%d%s", len(data), data)\n    return crypto.Keccak256([]byte(messsage))\n}\n')))}u.isMDXComponent=!0}}]);