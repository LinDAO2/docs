"use strict";(self.webpackChunknext_id_doc=self.webpackChunknext_id_doc||[]).push([[61],{4871:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=n(6600),r=(n(9496),n(9613));n(9295);const a={title:"Rust"},i=void 0,o={unversionedId:"developer-guide/rust",id:"developer-guide/rust",title:"Rust",description:"Proof Service",source:"@site/i18n/zh-Hans/docusaurus-plugin-content-docs/current/developer-guide/rust.md",sourceDirName:"developer-guide",slug:"/developer-guide/rust",permalink:"/zh-Hans/developer-guide/rust",draft:!1,editUrl:"https://github.com/nextdotid/docs/edit/main/docs/developer-guide/rust.md",tags:[],version:"current",frontMatter:{title:"Rust"},sidebar:"docs",previous:{title:"Go",permalink:"/zh-Hans/developer-guide/go"},next:{title:"TypeScript",permalink:"/zh-Hans/developer-guide/typescript"}},l={},d=[{value:"Proof Service",id:"proof-service",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"proof-service"},"Proof Service"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You could git clone and run this ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/nextdotid/Signature-Generating-Sample/tree/main/rust"},"Rust open demo")," as a help")),(0,r.kt)("p",null,"The core example of codes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="Cargo.toml"',title:'"Cargo.toml"'},'[dependencies]\nlibsecp256k1 = "0.7"\nhex = "0.4"\nsha3 = "0.10" # Keccak256\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use libsecp256k1::{SecretKey, Message};\nuse sha3::{Keccak256, Digest};\n\nconst SECRET_KEY: &str = "9DEBA3488458C0314E5FEF8920D3B117DD76415569CF270DB8FD864896C02732";\nconst SIGN_PAYLOAD: &str = "Test123123!";\n\nfn main() {\n    // Raw sign message\n    let sign_payload: String = SIGN_PAYLOAD.to_string();\n    // SecretKey instance\n    let secret_key = SecretKey::parse_slice(hex::decode(SECRET_KEY).unwrap().as_slice()).unwrap();\n    // Sign it\n    let personal_signature = personal_sign(&sign_payload, &secret_key);\n    // Verify it\n    println!("Signature: 0x{}", hex::encode(personal_signature));\n    // Signature: 0x52f210dadad13c4c8d0656e7380300a367a056631cf26950baa7de4f580187795c76b5fc94de5bd0b8af4d5df432687d900402cba86a12570af56be35ba8d56401\n}\n\n/// `web3.eth.personal.sign()`\nfn personal_sign(payload: &String, secret_key: &SecretKey) -> Vec<u8> {\n    // Wrap personal.sign() required signature struct\n    let personal_message = format!("\\x19Ethereum Signed Message:\\n{}{}", payload.len(), payload);\n    // Keccak256 it into a digest.\n    let mut hasher = Keccak256::default();\n    hasher.update(personal_message);\n    let digest: [u8; 32] = hasher.finalize().into();\n\n    // Sign the digest.\n    let (r_and_s, v) = libsecp256k1::sign(&Message::parse(&digest), secret_key);\n    // Rebuild the sig into a [u8; 65]\n    let mut signature: Vec<u8> = vec![];\n    signature.extend_from_slice(&r_and_s.r.b32()); // r (32 bytes)\n    signature.extend_from_slice(&r_and_s.s.b32()); // s (32 bytes)\n    signature.push(v.serialize()); // v (1 byte)\n    if signature.len() != 65 {\n        panic!("Signature length is not 65 bytes");\n    }\n    signature\n}\n')))}u.isMDXComponent=!0}}]);